import torchvision
import wandb
from hydra.utils import instantiate
from pytorch_lightning import LightningModule
from torch import nn
import torch
from torch.nn import functional as F
import typing as tp
from utils import FidScore

EPS = 1e-18


def gaussian_log_likelihood(x_true, mu, sigma):
    """
    Compute log-likelihood of objects x_true for the generated by model
    component-wise Gaussian distributions.
    Each object from x_true has K corresponding distrbutions from x_distr.
    Log-likelihood estimation must be computed for each pair of an object
    and a corresponding to the object distribution.
    Do not forget about computational stability!
    Do not divide log-likelihood by the dimensionality of the space of objects.
    Input: x_true, Tensor of shape n x D.
    Input: x_distr, Tensor of shape n x K x D - parameters of component-wise
           Gaussian distributions.
    Return: Tensor of shape n x K - log-likelihood for each pair of an object
            and a corresponding distribution.
    """
    log_pdf = - torch.sum(torch.log(sigma + EPS) + 0.5 * ((x_true.unsqueeze(1) - mu) / sigma) ** 2,
                          dim=(-1, -2, -3))  # - D / 2 * log(2 * pi)
    return log_pdf


def kl(q_mu, q_sigma, p_mu, p_sigma):
    """

    Compute KL-divergence KL(q || p) between n pairs of Gaussians
    with diagonal covariational matrices.
    Do not divide KL-divergence by the dimensionality of the latent space.

    Input: q_mu, p_mu, Tensor of shape n x d - mean vectors for n Gaussians.
    Input: q_sigma, p_sigma, Tensor of shape n x d - standard deviation
           vectors for n Gaussians.
    Return: Tensor of shape n - each component is KL-divergence between
            a corresponding pair of Gaussians.
    """
    return (torch.log(p_sigma + EPS) -
            torch.log(q_sigma + EPS) +
            (q_sigma ** 2 + (q_mu - p_mu) ** 2) / (2 * p_sigma ** 2 + EPS) -
            0.5).sum(-1)


class ClampLayer(nn.Module):
    def __init__(self, min=None, max=None):
        super().__init__()
        self.min = min
        self.max = max
        self.kwargs = {}
        if min is not None:
            self.kwargs['min'] = min
        if max is not None:
            self.kwargs['max'] = max

    def forward(self, input):
        return torch.clamp(input, **self.kwargs)


class Block(nn.Module):
    def __init__(self, in_features, out_features, kernel, stride=1, bias=False, upsample=False):
        super().__init__()
        self.upsample = upsample

        self.conv = nn.Conv2d(in_features, out_features, kernel, stride=stride, padding=(kernel - 1) // 2, bias=bias)
        self.norm = nn.BatchNorm2d(out_features)
        self.act = nn.LeakyReLU(0.2)

    def forward(self, x):
        if self.upsample:
            x = F.interpolate(x, scale_factor=2, mode='bilinear', align_corners=False, recompute_scale_factor=False)
        return self.act(self.norm(self.conv(x)))


class VAE(LightningModule):
    def __init__(self, latent_dim, optimizer_conf=None, *args, **kwargs):
        """
        Initialize model weights.
        Input: d, int - the dimensionality of the latent space.
        Input: D, int - the dimensionality of the object space.
        """
        super(VAE, self).__init__(*args, **kwargs)
        self.latent_dim = latent_dim
        self.optimizer_conf = optimizer_conf
        self.proposal_network = nn.Sequential(
            Block(3, 16, 3, stride=2),
            Block(16, 32, 3, stride=2),
            Block(32, 32, 3, stride=2),
            Block(32, 32, 3, stride=2),
            Block(32, 64, 3, stride=1).conv,
            nn.AdaptiveAvgPool3d(output_size=(64, 1, 1)),
            nn.Flatten()
        )

        self.proposal_mu_head = nn.Linear(64, self.latent_dim)
        self.proposal_sigma_head = nn.Sequential(
            nn.Linear(64, self.latent_dim),
            nn.Softplus()
        )

        self.generative_network = nn.Sequential(
            nn.Unflatten(1, (self.latent_dim, 1, 1)),
            nn.Conv2d(self.latent_dim, 32, 2, padding=1),
            nn.BatchNorm2d(32),
            nn.LeakyReLU(0.2),
            Block(32, 32, 3, upsample=True),
            Block(32, 32, 3, upsample=True),
            Block(32, 32, 3, upsample=True),
            Block(32, 32, 3, upsample=True),
            Block(32, 32, 3, upsample=True),
            Block(32, 32, 3).conv,
        )

        self.generative_mu_head = nn.Sequential(
            nn.Conv2d(32, 3, 1),
            ClampLayer(-10, 10),
            nn.Tanh()
        )
        self.generative_sigma_head = nn.Sequential(
            nn.Conv2d(32, 3, 1),
            ClampLayer(1e-3, None),
            nn.Softplus()
        )
        self.fid = FidScore()

    def proposal_distr(self, x):
        """
        Generate proposal distribution over z.
        Note that sigma is positive by design of neural network.
        Input: x, Tensor of shape n x D.
        Return: tuple(Tensor, Tensor),
                Each Tensor is a matrix of shape n x d.
                The first one is mu, the second one is sigma.
        """
        proposal = self.proposal_network(x)
        mu = self.proposal_mu_head(proposal)
        sigma = self.proposal_sigma_head(proposal)
        return mu, sigma

    def prior_distr(self, x):
        """
        Generate prior distribution over z.
        Note that sigma is positive by design of neural network.
        Input: x, Tensor of shape n x D.
        Return: tuple(Tensor, Tensor),
                Each Tensor is a matrix of shape n x d.
                The first one is mu, the second one is sigma.
        """
        mu = torch.zeros((x.shape[0], self.latent_dim)).type_as(x)
        sigma = torch.ones((x.shape[0], self.latent_dim)).type_as(x)
        return mu, sigma

    def sample_latent(self, mu, sigma, K=1):
        """
        Generate samples from Gaussians with diagonal covariance matrices in latent space.
        Input: mu, Tensor of shape n x d - mean vectors for n Gaussians.
        Input: sigma, Tensor of shape n x d - standard deviation vectors
               for n Gaussians.
        Input: K, int - number of samples from each Gaussian.
        Return: Tensor of shape n x K x d.
        """
        epsilon = torch.randn((mu.shape[0], K, mu.shape[1])).type_as(mu)
        sample = mu.unsqueeze(1) + sigma.unsqueeze(1) * epsilon
        return sample

    def generative_distr(self, z):
        """
        Compute a tensor of parameters of Bernoulli distribution over x
        given a tensor of latent representations.
        Input: z, Tensor of shape n x K x d - tensor of latent representations.
        Return: Tensor of shape n x K x D - parameters of Bernoulli distribution.
        """
        n, K, d = z.shape
        generates = self.generative_network(z.view((n * K, d)))
        nK, C, H, W = generates.shape
        mu = self.generative_mu_head(generates)
        sigma = self.generative_sigma_head(generates)
        return mu.view((n, K, -1, H, W)), sigma.view((n, K, -1, H, W))

    def training_step(self, batch, batch_idx):
        """
        Compute VLB for batch. The VLB for batch is an average of VLBs for batch's objects.
        VLB must be differentiable w. r. t. model parameters, so use reparametrization!
        Input: batch, Tensor of shape n x D.
        Return: Tensor, scalar - VLB.
        """
        batch, _ = batch
        mu, sigma = self.proposal_distr(batch)
        mu_prior, sigma_prior = self.prior_distr(batch)
        z = self.sample_latent(mu, sigma)
        mu_image, sigma_image = self.generative_distr(z)
        gll = gaussian_log_likelihood(batch, mu_image, sigma_image).mean()
        kl_ = kl(mu, sigma, mu_prior, sigma_prior).mean()
        vlb = gll - kl_
        self.log_dict(
            {
                'gaussian log-likelihood': gll,
                'kl divergence': kl_,
                'total': vlb
            }
        )
        return -vlb

    def forward(self, batch, K=1, *args, **kwargs):
        mu, sigma = self.proposal_distr(batch)
        z = self.sample_latent(mu, sigma, K)
        mu_image, sigma_image = self.generative_distr(z)
        return mu_image, sigma_image

    @torch.no_grad()
    def generate_samples(self, num_samples=1):
        """
        Generate samples from the model.
        Input: num_samples, int - number of samples to generate.
        Return: Tensor of shape num_samples x D.
        """
        device = next(iter(self.generative_network.parameters())).device
        mu, sigma = self.prior_distr(torch.empty((1, self.latent_dim), device=device, dtype=torch.float))
        z = self.sample_latent(mu, sigma, K=num_samples)
        samples, _ = self.generative_distr(z)
        return samples.squeeze(0)

    def validation_step(
            self,
            batch: tp.Tuple[torch.Tensor, torch.Tensor],
            batch_idx: int
    ):
        images, labels = batch
        reconstructions, _ = self.forward(images)
        reconstructions.squeeze_(1)
        self.fid(images, reconstructions)
        if batch_idx == 0:
            return {
                'real images': images,
                # 'real labels': labels,
            }
        return {
            'real images': None,
            # 'real labels': None
        }

    def validation_epoch_end(self, outputs: tp.List[tp.Any]) -> None:
        n_images = 5
        for output in outputs:
            if output['real images'] is not None:
                control_images = output['real images'][0:n_images]
                # control_labels = output['real labels'][0:n_images]
                break

        reconstructed, _ = self.forward(control_images)
        reconstructed.squeeze_(1)
        generated = self.generate_samples(n_images)
        self.log('fid score', self.fid)
        print(generated.shape, reconstructed.shape)
        self.logger.experiment.log(
            {
                'generated images': wandb.Image(torchvision.utils.make_grid(generated, nrow=n_images)),
                'reconstructed images': wandb.Image(
                    torchvision.utils.make_grid(
                        torch.vstack((control_images, reconstructed)), nrow=n_images))
            },
        )

    def configure_optimizers(self):
        return instantiate(self.optimizer_conf, params=self.parameters())
